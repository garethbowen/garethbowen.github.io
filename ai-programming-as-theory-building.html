<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>AI and the Theory Building View of programming - Gareth Bowen</title>
    <link rel="stylesheet" href="./style.css">
    <link rel="apple-touch-icon" sizes="180x180" href="./logo/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./logo/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./logo/favicon-16x16.png">
    <link rel="manifest" href="./site.webmanifest">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Overlock+SC&display=swap" rel="stylesheet">
  </head>
  <body>
    <div>
      <div class="contact">
        <div class="logo">
          <a href="https://gareth.nz"><img src="./logo/logo-white.svg" alt="Gareth Bowen" width="50" /></a>
        </div>
        <div class="social">
          <ul>
            <li><a href="mailto:gareth@bowenwebdesign.co.nz"><img src="./icons/icons8-email-64.png" width="32" height="32" alt="Email Gareth Bowen"/></a></li>
            <li><a href="https://www.linkedin.com/in/garethjbowen/"><img src="./icons/icons8-linkedin-64.png" width="32" height="32" alt="View Gareth Bowen LinkedIn profile"/></a></li>
            <li><a href="https://github.com/garethbowen"><img src="./icons/icons8-github-64.png" width="32" height="32" alt="See Gareth's software development at GitHub"/></a></li>
            <li><a href="https://www.strava.com/athletes/13372622"><img src="./icons/icons8-strava-64.png" width="32" height="32" alt="Follow Gareth on Strava"/></a></li>
            <li><a href="https://mastodon.nz/@garethbowen"><img src="./icons/icons8-mastodon-64.png" width="32" height="32" alt="Lurking on mastodon"/></a></li>
          </ul>
        </div>
      </div>
    </div>
    <div class="banner">
      <div>
        <h1>Gareth Bowen</h1>
      </div>
    </div>
    <div class="section-title">
      <div>
        <h2>AI and the Theory Building View of programming</h2>
        <p>15 April 2025</p>
      </div>
    </div>
    <div>
      <div>
        <p>The Theory Building View of programming as proposed by Peter Naur in 1985 has aged exceptionally well, and still explains issues with maintaining software that I've experienced during my career. However, a lot has changed in the last 40 years, for example, the original paper doesn't attempt to address any conflicts between the theory and AI assisted programming. This is an exploration of what the theory predicts for the future of coding.</p>
      </div>
    </div>
    <div class="splash">
      <div>
        <img src="./photos/ai-theory-building.jpg" alt="Artificial Intelligence android programming as theory building" height="448" width="832">
        <p class="caption">Generated by deepai.org</p>
      </div>
    </div>
    <div class="section-title">
      <div>
        <a id="introduction" href="#introduction"><h3>Introduction to the theory</h3></a>
      </div>
    </div>
    <div>
      <div>
        <p>If you haven't already, I recommend reading <a href="https://gwern.net/doc/cs/algorithm/1985-naur.pdf">the paper</a>, or listening to the <a href="https://futureofcoding.org/episodes/061.html">Future of Coding podcast</a> which was how I was introduced to the idea.</p>
        <p class="quote">"A main claim of the Theory Building View of programming is that an essential part of any program, the theory of it, is something that could not conceivably be expressed, but is inextricably bound to human beings."</p>
        <p>My TL;DR is that the act of programming is to build a theory of the software and how it relates to the real world problems it aims to solve. This theory is the <strong>primary</strong> output of the activity, and more important than the code itself or any documentation. It is impossible to adequately document the theory and the only way to build the theory is by programming, ideally with another programmer who has already built the theory for themselves. If no programmers with the theory of the software remain, then the product is effectively dead, and if significant changes are required it will be cheaper to rewrite the software entirely.</p>
        <p class="quote">"On the Theory Building View of programming the theory built by the programmers has primacy over such other products as program texts, user documentation, and additional documentation such as specifications."</p>
      </div>
    </div>
    <div class="section-title">
      <div>
        <a id="auto-complete-ai" href="#auto-complete-ai"><h3>Autocomplete AI</h3></a>
      </div>
    </div>
    <div>
      <div>
        <p>Most programmers use AI assistants for what is essentially an advanced autocomplete tool. For example, when given a function definition it will propose an implementation which is then reviewed by the programmer before committing it. Using AI this way means the programmer misses out on understanding the minutia of the implementation, but so long as it's used only for low level functionality it's not likely to contribute to the overall theory. In fact this likely means the programmer can spend more time on higher level considerations, deepening their understanding of the theory. This is similar to invoking a third party library for specific functionality, in that the programmer is intentionally choosing to delegate the details and focus on the theory at a higher level.</p>
        <p class="quote">"The building of the program is the same as the building of the theory of it by and in the team of programmers."</p>
        <p>A more advanced use case is to use AI to write the tests for the human written code. Again, if this is used for low level unit tests then this likely won't impact on theory building, but high level testing is essential for challenging the programmers assumptions about the software and therefore the theory. One of the key features of <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a> is that the testing forces the programmer to think about the real world requirements first - AI generated testing is the antithesis of TDD, because it reduces the amount of time the programmer must spend considering the requirements.</p>
        <p class="quote">"What characterizes intellectual activity, over and beyond activity that is merely intelligent, is the person's building and having a theory, where theory is understood as the knowledge a person must have in order not only to do certain things intelligently but also to explain them, to answer queries about them, to argue about them, and so forth."</p>
      </div>
    </div>
    <div class="section-title">
      <div>
        <a id="pairing-with-ai" href="#pairing-with-ai"><h3>Pairing with AI</h3></a>
      </div>
    </div>
    <div>
      <div>
        <p>AI assistants are also used to review changes, either as a synchronous pair, or an asynchronous PR reviewer. This approach is much more consistent with theory building as the human is driving the change, and their understanding of the theory is being challenged by the assistant. Here you get many of the benefits of <a href="https://en.wikipedia.org/wiki/Pair_programming">Pair Programming</a> without the downsides of co-location, inflexible schedules, and cost.</p>
        <p>However Naur posits that the only way for new programmers to build the theory of the program is to be actively engaged in developing it, ideally with other programmers who already have a working theory. If the team <strong>relies</strong> on AI for pairing or reviewing then this opportunity for theory building is lost, and any new programmers will struggle to build the model leading to poor quality contributions. If you accept that working together is essential as a theory building tool, then it cannot be replaced by AI. Instead, use assistants to complement existing processes, for example, as an <strong>additional</strong> code reviewer.</p>
        <p class="quote">"For a new programmer to come to possess an existing theory of a program it is insufficient that he or she has the opportunity to become familiar with the program text and other documentation. What is required is that the new programmer has the opportunity to work in close contact with the programmers who already possess the theory..."</p>
      </div>
    </div>
    <div class="section-title">
      <div>
        <a id="outsourcing-to-ai" href="#outsourcing-to-ai"><h3>Outsourcing to AI</h3></a>
      </div>
    </div>
    <div>
      <div>
        <p>When taken to the ultimate extreme, the entire software development process, including theory building, can be outsourced to AI. Much like outsourcing to human programmers outside your organisation, this can be appropriate if software sustainability is not required, for example, a throwaway proof of concept, or the software is not core business. However if the product is vital to your business then any form of outsourcing has risks. While the ownership of the code and documentation is clear, Naur proposes that the theory is the primary output, and without any way to communicate the theory you cannot take ownership of it.</p>
        <p class="quote">"The conclusion seems inescapable that at least with certain kinds of large programs, the continued adaptation, modification, and correction of errors in them, is essentially dependent on a certain kind of knowledge possessed by a group of programmers who are closely and continuously connected with them."</p>
        <p>It would be possible to retain ownership of the AI that has built a theory of the software so long as its “memory” was owned by your organisation, but beware of relying on a third party who could change terms of service, price, or implementation without recourse. If access to the theory is lost, then the product is effectively dead.</p>
        <p class="quote">"The death of a program happens when the programmer team possessing its theory is dissolved."</p>
        <p class="quote">"A very important consequence of the Theory Building View is that program revival, that is reestablishing the theory of a program merely from the documentation, is strictly impossible."</p>
      </div>
    </div>
    <div class="section-title">
      <div>
        <a id="conclusion" href="#conclusion"><h3>Conclusion</h3></a>
      </div>
    </div>
    <div>
      <div>
        <p>Naur's theory of Programming as Theory Building shows there are no shortcuts to building a team with a theory of the software and how it relates to the real world. The theory is the primary output of software development, more important than the code or documentation. However it is also impossible to adequately communicate the theory, so it needs to be continuously built and refined by a team of programmers working together. If the team is replaced either by human or artificial intelligence the theory is lost and a complete rewrite will be the cheapest option for making future modifications.</p>
        <p class="quote">"Since this theory by its very nature is part of the mental possession of each programmer, it follows that the notion of the programmer as an easily replaceable component in the program production activity has to be abandoned."</p>
        <p>Perhaps AI will prove Naur wrong, or become advanced enough to build the theory itself, but until then a team of full time human programmers is still required for any form of sustainable software development.</p>
      </div>
    </div>
    <div class="footer">
      <div>
        &copy; Gareth Bowen
      </div>
    </div>
  </body>
</html>
